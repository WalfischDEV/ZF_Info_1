\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[german]{babel}
\usepackage[T1]{fontenc}
\usepackage{mathtools,amssymb,lipsum}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage[svgnames]{xcolor}

\usepackage{listings}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}



\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\usepackage[framemethod=tikz]{mdframed}



\definecolor{sealgreen}{HTML}{00c693} 
\definecolor{redred}{HTML}{C60033}

\usepackage[notes,backend=biber]{biblatex-chicago}

% Shorthands
\newcommand*\iffdef{\overset{\text{merke}}{\iff}}
\DeclarePairedDelimiter\abs{\lvert}{\rvert}
\DeclarePairedDelimiter\norm{\lVert}{\rVert}

% Theorem
\mdtheorem[
  linecolor=sealgreen,
  frametitlefont=\sffamily\bfseries\color{white},
  frametitlebackgroundcolor= sealgreen ,
]{Merke}{Merke}[subsection]

\mdtheorem[
  linecolor=redred,
  frametitlefont=\sffamily\bfseries\color{white},
  frametitlebackgroundcolor= redred ,
]{Wichtig}{Wichtig}[subsection]



\addbibresource{sample.bib}

\title{Informatik I - Zusammenfassung}
\begin{document}
\maketitle
\tableofcontents

\section{Funktionen und Module}

\subsection{Methoden}

\subsubsection{Felder als Formalparameter}

\begin{Merke}[Call-by-reference (Strukturierte Datentypen)]
Übergabe der Parameter an Funktionen mithilfe einer Referenz. Änderungen wirken sich auf den ursprünglichen Wert aus!\\

Operationen mit Variablen des methodenaufrufenden Codes selbst.\\
\textbf{Strukturierte Daten} werden per \textbf{Referenz} übergeben! Änderungen der per Referenz übergebenen Parameter sind im \textbf{aufrufenden Code} sichtbar!\\

Beispiel: Einträge in übergebenen Feldern werden durch Methoden verändert! Das passiert bei reinen Integern (unstrukturierten Daten) nicht!
\end{Merke}

\subsubsection{Der Laufzeitstapel}

\begin{Merke}[Definition]
Datenstruktur zur Verwaltung des Speichers der von den Methoden verarbeitet wird.\\
\textbf{Speicherbereich, in dem lokale Variablen abgespeichert werden.}
\end{Merke}

\begin{Merke}[Stack Frame - Aktivierungsrahmen]
 Abschnitt im Laufzeitstapel mit entsprechenden Speicherplätzen wird bei Aufruf \textbf{neu angelegt} und mit \textbf{[V,R]} initialisiert. Wird nach Wertübergabe (z.B. return) an Aufrufer freigegeben. 
\end{Merke}

\begin{Merke}[Relevante Daten: V,R ]
\begin{itemize}
\item \textbf{V:} Werte aller \textbf{lokalen Variablen} (Formalparameter + im Rumpf deklariert)
\item \textbf{R:} \textcolor{sealgreen}{Rücksprungadresse} = Adresse des Befehls der dem Aufruf folgt (z.B. Vorherige Methode)
\end{itemize}
\end{Merke}

\begin{figure}[htbp] 
  \centering
     \includegraphics[width=0.8\textwidth]{Bilder/LFT_1.png}
  \label{fig:Bild1}
\end{figure}

Analogie: Aktenstapel

\subsubsection{Rekursion}

\begin{Merke}[Rekursion]
Wird durch den Laufzeitstapel ermöglicht.\\
\textbf{Rekursion} = sich selbst aufrufende Funktionen.\\
Beispiel: Fakultätsfunktion.\\
Grundmuster: \textbf{Initialisiere - Terminiere (falls trivial) - Rekurriere}\\
Jede Rekursion muss zu einem \textbf{Basisfall} führen. Sonst: \textsc{StackOverflowError}

\begin{itemize}
\item \textbf{Einfache Rekursion:} Lösung wird aus einem kleinen Vorgängerproblem gelöst. Geringe Aufwandreduktion pro Rekursionsschritt.
\item \textbf{Mehrfache Rekursion:} Gesamtaufwand gleichmäßig aufteilen. Verwende \textbf{Teile- und Herrsche- Algorithmus:}
\begin{itemize}
\item Teile Problem in mehrere Unterprobleme ähnlicher Größe
\item Löse die Unterprobleme durch Teillösungen
\item Kombiniere die Teillösungen zur Problemlösung
\end{itemize}

\end{itemize}

\end{Merke}

\begin{figure}[htbp] 
  \centering
     \includegraphics[width=0.8\textwidth]{Bilder/LFT_2.png}
  \label{fig:Bild1}
\end{figure}

\begin{Merke}[Rekursionstiefe]
ist die Tiefe seines Rekursionsbaums (maximale Anzahl von Kanten auf einem Wurzel -> Blatt-Pfad)
\end{Merke}

\begin{Merke} [Traversierung]
\begin{itemize}
\item \textbf{Inorder-Travesierung:} Links - Wurzel - Rechts (z.B. Scheiben)
\item \textbf{Postorder-Travesierung:} Links - Rechts - Wurzel (z.B. Fibonacci)
\end{itemize}
\end{Merke}

\begin{Merke}[Memoisation]
Wiederholungen vermeiden durch \textbf{zwischenspeichern} in einem Feld.\\
Beispiel Fibonacci:
\begin{lstlisting}
   static int[] f = new int[N];
    public static void mFib() {
	f[0] = 0; f[1] = 1; 
	for (int i = 2; i < N; ++i)
	    f[i] = f[i-1] + f[i-2];
    }
\end{lstlisting}

\end{Merke}

\begin{Wichtig}[Rekursion]
\begin{itemize}
\item Es wird ein Basisfall benötigt!
\item Wir müssen die Problemgröße durch Rekursion reduzieren.
\item Der Speicherbedarf darf nicht zu groß werden.
\item Wiederholte Berechnungen vermeiden!
\end{itemize}
\end{Wichtig}

\subsection{Modulare Programmierung}
Verwendung von (eigens) programmierten Klassen in anderen Programmen/Klassen.

\begin{Merke}[\textsc{public}, Clienten]
Zugriff wird durch das Schlüsselwort \textsc{public} ermöglicht!\\
\begin{itemize}
\item \textbf{Clienten:} Eine Klasse, die Dienste einer anderen Klasse \textbf{C} nutzt, heißt \textbf{Clientklasse} von \textbf{C}.
\item Klassendefinition: \textsc{public class C} ermöglicht Benutzung aller \textsc{public} Elemente der Klasse durch Clienten.
\end{itemize}
\end{Merke}

\begin{Merke}[Modul]
Ein \textbf{Modul} wird durch den Java-Code einer *.java Datei definiert.\\
Paradigma der modularen Programmierung:
\begin{itemize}
\item Aufteilung in übersichtliche Einheiten.
\item implementiere, dokumentiere und teste die Module \textbf{einzeln}!
\item implementiere \textsc{EV(S)A} 
\end{itemize}
Idee: Zusammenfassung thematisch ähnlicher Methoden
\begin{itemize}
\item Dokumentation in einer \textbf{API}.
\item \textsc{public class} und \textbf{public} Methoden.
\item \textbf{Testclient:} \textsc{main} Methode im Modul, die den gesamten Code ausführt und datengesteuerte Tests ermöglicht. 
\item Nutzerbibliotheken sind keine eigenständige Applikationen!
\end{itemize}

\end{Merke}

\section{Strukturierte Daten}
\subsection{Weiteres zu Feldern}
\begin{Merke}[Heap]

Speicherbereich (dynamischer Speicher), in welchem zur Laufzeit eines Programms Speicherabschnitte angefordert werden können.\\
Hier werden beispielsweise die \textbf{Feldinhalte} eines Feldes abgespeichert.

\end{Merke}

\begin{Merke}[Abspeicherung von Feldern]
Die Feldlänge entsteht unter Umständen erst zur Laufzeit. Dementsprechend wird zunächst eine \textbf{Referenz} (=Adresse) (\textsc{new int[n])} auf das neu angelegte Feld in einer Variable abgelegt.\\
Änderungen?
\begin{itemize}
\item Feldinhalt: Ja!
\item Länge: Nein!
\item Referenz: Ja!
\end{itemize}
Beispiel:\\


\end{Merke}

\begin{figure}[htbp] 
  \centering
     \includegraphics[width=0.8\textwidth]{Bilder/Felder1.png}
  \label{fig:Bild1}
\end{figure}

\begin{Merke} [Call-by-value-Prinzip]
Übergabe der Parameter an Funktionen mithilfe einer Kopie. Änderungen wirken sich \textbf{nicht} auf den ursprünglichen Wert aus!\\

Beispiel: Bei der Übergabe eines Feldes wird die Anfangsadresse in die Formalparameter kopiert. 
\end{Merke}

\begin{Merke}[Sortierung]
Zwei Einfache Sortierverfahren:\\
\begin{itemize}
\item \textbf{Selection-Sort:} Minima nach vorn tauschen:\\
\begin{lstlisting}
	public static void sort(double[] f) { // Selectionsort
		final int N = f.length; 
		for (int i = 0; i < N-1; i++) {
	    	int m = i;
	   	 	for (int j = i+1; j < N; j++) // Index m  des Minimums von ..
			if ( f[j] < f[m])         // .. [f[i],f[i+1],...,f[N-1]] ..
		    m = j;                // .. bestimmen und nach Position ..
	    	double tmp=f[m]; f[m]=f[i]; f[i]=tmp; // .. i tauschen
		} 
    }
\end{lstlisting}
\item \textbf{Insertion-Sort:} In Anfangsabschnitte sortiert einfügen.
\begin{lstlisting}
	public static void sort(double[] f) { // Insertionsort
      final int N = f.length; 
      for (int i = 1; i < N; i++) { // f[0], ..., f[i-1] ist bereits sortiert
	// f[i] an richtiger Stelle einfuegen, d.h soweit noetig ..
	  for (int j = i; j > 0 && f[j] < f[j-1]; j--) { // f[i] nach links ..
              double tmp=f[j]; f[j]=f[j-1]; f[j-1]=tmp; // .. "durchtauschen".
	  }
      }
    }  
\end{lstlisting}
\end{itemize}
\end{Merke}

\subsection{Verbunddaten}

\begin{Wichtig}[Verbund]
Ein \textbf{Verbund} (Synonym: Datensatz) ist ein Datenobjekt, das eine Anzahl von Komponenten beliebigen Typs zusammenfasst.\\
Beispiel: \textbf{Studenten}: [name, matrikelnummer, fach]
\end{Wichtig}

\begin{Merke} [Programmierung von Verbund-Daten]
\begin{itemize}
\item Bauplan wird durch eine Klasse beschrieben.
\item Ein Datenobjekt heißt \textbf{Instanz}.
\item Der aktuelle Zustand einer Instanz wird in den \textbf{Instanzvariablen} gespeichert.
\begin{lstlisting}
public class Student{
	String name; // Instanzvariablen ..
	int matrikelnr; // .. (auch Instanz- ..
	String fach; // .. attribute genannt )
...
}
\end{lstlisting}
\item Konstruktionsaufruf und Zugriff:\\
\begin{lstlisting}
  Student s;
  s = new Student("Fritze Bollmann", 20091234, "Biologie");
  ...
  System.out.pritnln(s.name); // Ausgabe: Fritze Bollmann
\end{lstlisting}
\end{itemize}
\end{Merke}
\begin{figure}[htbp] 
  \centering
     \includegraphics[width=0.8\textwidth]{Bilder/Verbunddaten1.png}
  \label{fig:Bild1}
\end{figure}

\begin{Merke}[\textsc{this}]
Das Schlüsselwort \texttt{this} speichert eine Referenz auf das aktuelle Datenobjekt.
\begin{lstlisting}
public Student(String name, int matrikelnr, String fach) {
  this.name = name; // Formalparameter verdecken ..
  this.matrikelnr = matrikelnr; // .. gleichnamige Attribute!
  this.fach = fach; // this macht sie wieder unterscheidbar.
}
\end{lstlisting}
\end{Merke}

\begin{Merke}[Zugriffsmodifizierer]
Schlüsselwörter \texttt{private} und \texttt{public} steuern die Sichtbarkeit von Klassenelementen vom Clientcode aus gesehen.\\
\begin{itemize}
\item public-Elemente: sind von jeder anderen Klasse im Klassenpfad sichtbar.
\item private-Elemente: sind außerhalb der definierenden Klasse nicht sichtbar.
\end{itemize}
\end{Merke}

\begin{Merke}[Hash-Codes]
Drucken von Verbunddaten / Arrays: Ausgabe eines Indentifikators: Klassenname zusammen mit einem hexadezimalen \textsc{int}-Wert = \textbf{Hashcode} des Datenobjekts (\textbf{Speicheradresse!}).
\end{Merke}

\subsection{Verkettete Datenstrukturen}

\begin{Merke}[Statische Datenstrukturen]
Elementare und Feld- oder Verbunddaten haben veränderliche Werte aber Struktur und Größe sind \textbf{statisch}, d.h. bleiben über die gesamte Laufzeit gleich:
\begin{itemize}
\item \texttt{int x = 42;} - 4 aufeinanderfolgende Bytes
\item \texttt{int[] f = new int[n];} - aufeinanderfolgende \texttt{int}- Speicherstellen
\item \texttt{Person p = new Person(..);} - Verbund verschiedener Komponenten
\end{itemize}
\end{Merke}

\begin{Merke}[Dynamische Datenstrukturen]
bestehen aus gleichartigen statischen Datenobjekten (\textbf{Knoten}) veränderlicher Anzahl und Beziehungsstruktur:
\begin{itemize}
\item Listen veränderlicher Länge
\item baumartige Strukturen (linker/rechter Nachfolger...)
\item Netzwerke beliebiger Nachbarschaften
\end{itemize}
\end{Merke}

\begin{figure}[htbp] 
  \centering
     \includegraphics[width=0.8\textwidth]{Bilder/verkettetedatenstrukturen.png}
  \label{fig:Bild1}
\end{figure}

\begin{Merke}[Eine einfache Kette]
Wir benötigen eine \textbf{dynamische Datenstruktur:}\\
\textbf{Knotentyp und Verkettungstruktur:}
\begin{lstlisting}
class ZahlKnoten {
	double zahl;
	ZahlKnoten next;
	public ZahlKnoten (double zahl, ZahlKnoten next){
		this.zahl = zahl;
		this.next = next;
	}
}
\end{lstlisting}
\textbf{Aufbau der Liste:}
\begin{lstlisting}

\end{lstlisting}
\begin{lstlisting}
public class Zahlspeicher {
	private static ZahlKnoten anfang = null;
	public static void speichere(double zahl){
		anfang = new ZahlKnoten(zahl, anfang);
	}
	public static void main(String[] args){
		while (!StdIn.isEmpty()){
			speichere (StdIn.readDouble()); //Einlesen 47.11, 0.8, 15.0,..
		}
		
		ZahlKnoten iter = anfang;
		while (iter != null){
			System.out.println(iter.zahl);
			iter = iter.next;
		}
	}
}
\end{lstlisting}
\end{Merke}

\begin{figure}[htbp] 
  \centering
     \includegraphics[width=0.8\textwidth]{Bilder/liste1.png}
  \label{fig:Bild1}
\end{figure}
\begin{figure}[htbp] 
  \centering
     \includegraphics[width=0.8\textwidth]{Bilder/liste2.png}
  \label{fig:Bild1}
\end{figure}
\begin{figure}[htbp] 
  \centering
     \includegraphics[width=0.8\textwidth]{Bilder/liste3.png}
  \label{fig:Bild1}
\end{figure}

\subsection{Speicherorganisation}
\begin{Merke}[Abläufe, die die Speicherung beeinflussen]
\begin{itemize}
\item Compilezeit: Compiler legt anhand der Deklarationen relative Adressen fest.
\item Ladezeit: statischer Code wird in den Hauptspeicher geladen (z.B. Zuordnung absoluter Speicheradressen an statische Variablen)
\item Laufzeit: 
\begin{itemize}
\item statischer Code bleibt im Speicher
\item bei jedem Methodenaufruf wird im Laufzeitstapel Platz für lokale Variablen angelegt und initialisiert.
\item bei jedem Konstruktoraufruf wird im \textbf{Heap} Speicher für erzeugte Datenobjekte angelegt und initialisiert.
\end{itemize}
\end{itemize}
\end{Merke}

\begin{Merke}[Lebenszeit eines Beizeichners]
Zeit, in der er physikalischen Speicher belegt (innerhalb der Laufzeit)
\end{Merke}

\begin{Merke}[Speicherbereiche]
\begin{itemize}
\item \textbf{Method area:} Speicherung des Bytecodes benötigter Klassen (inkl. ihrer statischen Variablen); \textit{Lebenszeit: Laufzeit der Klassen}
\item \textbf{Stack: } Speicherung von Aktivierungssätzen von Methoden und Konstruktoren, d.h. lokale Variablen und Rücksprungadressen; \textit{Lebenszeit: Ausführungszeit der Methode /des Konstruktors, Speicherfreigabe wenn unbenötigt! }
\item  \textbf{Heap: } Speicherung von per Konstruktor angelegten Datensätze; \textit{Lebenszeit: Solange, wie das Datenobjekt durch Referenzkette von MA / Stack erreichbar ist.}
\end{itemize}
\end{Merke}


\begin{Merke}[Garbage-Collection]
Verweiste Objekte, die Speicher belegen, aber auf die nicht mehr zugegriffen werden kann werden durch einen \textbf{Garbage-Collector} überwacht und gegebenen falls Speicher freigegeben. 
\end{Merke}

\section{Objektorientierte Programmierung}
\subsection{Klassentypen verwenden}

\begin{Merke}[Referenzdatentypen]
Zugriff erfolgt anhand von Referenzen. Man spricht auch von \textbf{Klassentyp}.\\
Beispiele: Felder und Verbunde, Strings (Speicherung im Heap).
\end{Merke}

\begin{Merke} [Klassentypen]
\begin{itemize}
\item Standardklassen: Klassentypen, die (so wie \texttt{String}) zur Hava-API gehören.
\item Nutzerklassen: Klassentypen aus fremden Quellen oder selbst implementierte Klassentypen.
\end{itemize}
\end{Merke}

\begin{Merke} [Instanzen]
Jedes Objekt ist eine \textbf{Instanz} eines Datums des jeweiligen Typs.
\end{Merke}
\begin{figure}[htbp] 
  \centering
     \includegraphics[width=0.8\textwidth]{Bilder/vergleich.png}
  \label{fig:Bild1}
\end{figure}

\begin{Merke} [Unterschied zu Verbunddatentypen]
Wir haben nun lebendige Objekte. Sie haben einen \textbf{Zustand}, beschrieben durch den aktuellen Wert und ein \textbf{Verhalten}, beschrieben durch die Instanzmethoden.
\end{Merke}

\end{document}